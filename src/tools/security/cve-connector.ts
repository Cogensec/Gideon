import { SecurityConnector, SecurityQuery, NormalizedData } from './types.js';
import { rateLimitedFetch } from '../../utils/rate-limiter.js';
import { getCached, setCached, generateCacheKey } from '../../utils/cache.js';
import { getSourceConfig } from '../../utils/config-loader.js';

export const CVEConnector: SecurityConnector = {
  name: 'cve_connector',
  description: 'Searches CVE database (NVD) and CISA KEV catalog for vulnerability information',

  async fetch(query: SecurityQuery): Promise<any> {
    const cacheKey = generateCacheKey('cve', query);
    const cached = getCached(cacheKey);
    if (cached) {
      return { ...cached, _cached: true };
    }

    const config = getSourceConfig('nvd');
    if (!config || !config.enabled) {
      throw new Error('NVD connector is not enabled in configuration');
    }

    const results = await rateLimitedFetch('nvd', async () => {
      const apiKey = process.env.NVD_API_KEY || '';

      const params = new URLSearchParams({
        keywordSearch: query.query,
        resultsPerPage: '20',
      });

      // Add date filters if provided
      if (query.timeframe?.start) {
        params.set('pubStartDate', query.timeframe.start);
      }
      if (query.timeframe?.end) {
        params.set('pubEndDate', query.timeframe.end);
      }

      const response = await fetch(`${config.base_url}?${params}`, {
        headers: apiKey ? { 'apiKey': apiKey } : {},
      });

      if (!response.ok) {
        throw new Error(`NVD API error: ${response.status} ${response.statusText}`);
      }

      return response.json();
    });

    const ttl = config.cache_ttl;
    setCached(cacheKey, results, ttl);

    return { ...results, _cached: false };
  },

  normalize(rawData: any): NormalizedData[] {
    const vulnerabilities = rawData.vulnerabilities || [];

    return vulnerabilities.map((vuln: any) => {
      const cve = vuln.cve;
      const cveId = cve.id;

      // Extract CVSS score and severity
      const metrics = cve.metrics?.cvssMetricV31?.[0] ||
                     cve.metrics?.cvssMetricV30?.[0] ||
                     cve.metrics?.cvssMetricV2?.[0];

      const cvssScore = metrics?.cvssData?.baseScore || 0;
      const severity = metrics?.cvssData?.baseSeverity ||
                      (cvssScore >= 9.0 ? 'CRITICAL' :
                       cvssScore >= 7.0 ? 'HIGH' :
                       cvssScore >= 4.0 ? 'MEDIUM' :
                       cvssScore > 0 ? 'LOW' : 'UNKNOWN');

      // Map CVSS severity to our standard
      const severityMap: Record<string, NormalizedData['severity']> = {
        'CRITICAL': 'CRITICAL',
        'HIGH': 'HIGH',
        'MEDIUM': 'MEDIUM',
        'LOW': 'LOW',
        'INFORMATIONAL': 'INFORMATIONAL',
      };

      // Extract CWE information
      const weaknesses = cve.weaknesses?.map((w: any) =>
        w.description?.map((d: any) => d.value).join(', ')
      ).filter(Boolean) || [];

      // Extract affected products/configurations
      const configurations = cve.configurations?.nodes || [];
      const affectedProducts = new Set<string>();

      configurations.forEach((node: any) => {
        node.cpeMatch?.forEach((cpe: any) => {
          if (cpe.criteria) {
            // Extract vendor and product from CPE string
            // Format: cpe:2.3:a:vendor:product:version:...
            const parts = cpe.criteria.split(':');
            if (parts.length >= 5) {
              affectedProducts.add(`${parts[3]}:${parts[4]}`);
            }
          }
        });
      });

      return {
        id: cveId,
        source: 'nvd',
        type: 'cve',
        severity: severityMap[severity] || 'INFORMATIONAL',
        confidence: 1.0, // NVD is authoritative
        summary: cve.descriptions?.[0]?.value || 'No description available',
        details: {
          cvssScore,
          vectorString: metrics?.cvssData?.vectorString,
          severity,
          publishedDate: cve.published,
          lastModified: cve.lastModified,
          weaknesses: weaknesses.slice(0, 3),
          references: cve.references?.slice(0, 5).map((ref: any) => ({
            url: ref.url,
            source: ref.source,
            tags: ref.tags,
          })) || [],
          affectedProducts: Array.from(affectedProducts).slice(0, 10),
          exploitability: {
            // These would be enriched from CISA KEV in a production system
            knownExploited: false,
            exploitAvailable: false,
          },
        },
        timestamp: cve.published,
        url: `https://nvd.nist.gov/vuln/detail/${cveId}`,
      };
    });
  },

  rank(results: NormalizedData[]): NormalizedData[] {
    // Sort by severity (CRITICAL first) then by CVSS score (if available)
    const severityOrder = {
      CRITICAL: 0,
      HIGH: 1,
      MEDIUM: 2,
      LOW: 3,
      INFORMATIONAL: 4
    };

    return results.sort((a, b) => {
      const severityDiff = (severityOrder[a.severity || 'INFORMATIONAL'] || 4) -
                           (severityOrder[b.severity || 'INFORMATIONAL'] || 4);
      if (severityDiff !== 0) return severityDiff;

      const scoreA = a.details?.cvssScore || 0;
      const scoreB = b.details?.cvssScore || 0;
      return scoreB - scoreA;
    });
  },
};
